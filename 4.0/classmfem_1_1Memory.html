<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>MFEM: mfem::Memory&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="https://cdn.llnl.gov/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MFEM
   &#160;<span id="projectnumber">v4.0</span>
   </div>
   <div id="projectbrief">Finite element discretization library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemfem.html">mfem</a></li><li class="navelem"><a class="el" href="classmfem_1_1Memory.html">Memory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmfem_1_1Memory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mfem::Memory&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class used by MFEM to store pointers to host and/or device memory.  
 <a href="classmfem_1_1Memory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for mfem::Memory&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmfem_1_1Memory__coll__graph.svg" width="235" height="144"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7af6e87336d9ae575d795a92511fd43c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a7af6e87336d9ae575d795a92511fd43c">Memory</a> ()</td></tr>
<tr class="memdesc:a7af6e87336d9ae575d795a92511fd43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor: no initialization.  <a href="#a7af6e87336d9ae575d795a92511fd43c">More...</a><br/></td></tr>
<tr class="separator:a7af6e87336d9ae575d795a92511fd43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbee21dd0c326971e91d11fa4245bbf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#abbee21dd0c326971e91d11fa4245bbf3">Memory</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;orig)=default</td></tr>
<tr class="memdesc:abbee21dd0c326971e91d11fa4245bbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: default.  <a href="#abbee21dd0c326971e91d11fa4245bbf3">More...</a><br/></td></tr>
<tr class="separator:abbee21dd0c326971e91d11fa4245bbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23d9cfade7ef4ab02cba0d57ecf039a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ab23d9cfade7ef4ab02cba0d57ecf039a">Memory</a> (<a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;&amp;orig)=default</td></tr>
<tr class="memdesc:ab23d9cfade7ef4ab02cba0d57ecf039a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor: default.  <a href="#ab23d9cfade7ef4ab02cba0d57ecf039a">More...</a><br/></td></tr>
<tr class="separator:ab23d9cfade7ef4ab02cba0d57ecf039a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147b6128bf463085665af1f6ea56eaff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a147b6128bf463085665af1f6ea56eaff">operator=</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;orig)=default</td></tr>
<tr class="memdesc:a147b6128bf463085665af1f6ea56eaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assignment operator: default.  <a href="#a147b6128bf463085665af1f6ea56eaff">More...</a><br/></td></tr>
<tr class="separator:a147b6128bf463085665af1f6ea56eaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2aeb6c8b77fd55a796a7398ccb1ba2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#aaa2aeb6c8b77fd55a796a7398ccb1ba2">operator=</a> (<a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;&amp;orig)=default</td></tr>
<tr class="memdesc:aaa2aeb6c8b77fd55a796a7398ccb1ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assignment operator: default.  <a href="#aaa2aeb6c8b77fd55a796a7398ccb1ba2">More...</a><br/></td></tr>
<tr class="separator:aaa2aeb6c8b77fd55a796a7398ccb1ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c01fd9d1a0c4ab67a0ca0c98680412"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ae1c01fd9d1a0c4ab67a0ca0c98680412">Memory</a> (int size)</td></tr>
<tr class="memdesc:ae1c01fd9d1a0c4ab67a0ca0c98680412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate host memory for <em>size</em> entries.  <a href="#ae1c01fd9d1a0c4ab67a0ca0c98680412">More...</a><br/></td></tr>
<tr class="separator:ae1c01fd9d1a0c4ab67a0ca0c98680412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102f6d8ce2d661f85de4b0f128699515"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a102f6d8ce2d661f85de4b0f128699515">Memory</a> (int size, <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> mt)</td></tr>
<tr class="memdesc:a102f6d8ce2d661f85de4b0f128699515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for <em>size</em> entries with the given MemoryType <em>mt</em>.  <a href="#a102f6d8ce2d661f85de4b0f128699515">More...</a><br/></td></tr>
<tr class="separator:a102f6d8ce2d661f85de4b0f128699515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa79572a7c2f7a6c9fb4aeb84ad4661"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#affa79572a7c2f7a6c9fb4aeb84ad4661">Memory</a> (T *ptr, int size, bool own)</td></tr>
<tr class="memdesc:affa79572a7c2f7a6c9fb4aeb84ad4661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an externally allocated host pointer, <em>ptr</em> with type <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6ab9361011891280a44d85b967739cc6a5" title="Host memory; using new[] and delete[]. ">MemoryType::HOST</a>.  <a href="#affa79572a7c2f7a6c9fb4aeb84ad4661">More...</a><br/></td></tr>
<tr class="separator:affa79572a7c2f7a6c9fb4aeb84ad4661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b741efdece127b62d558f2d6cda057"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ae6b741efdece127b62d558f2d6cda057">Memory</a> (T *ptr, int size, <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> mt, bool own)</td></tr>
<tr class="memdesc:ae6b741efdece127b62d558f2d6cda057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an externally allocated pointer, <em>ptr</em>, of the given MemoryType.  <a href="#ae6b741efdece127b62d558f2d6cda057">More...</a><br/></td></tr>
<tr class="separator:ae6b741efdece127b62d558f2d6cda057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f74a8f481da9350110e69403339d44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a12f74a8f481da9350110e69403339d44">Memory</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;base, int offset, int size)</td></tr>
<tr class="memdesc:a12f74a8f481da9350110e69403339d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias constructor. Create a <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object that points inside the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object <em>base</em>.  <a href="#a12f74a8f481da9350110e69403339d44">More...</a><br/></td></tr>
<tr class="separator:a12f74a8f481da9350110e69403339d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb9e2bc14717bc0ffdd0a28588bc4e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a7cb9e2bc14717bc0ffdd0a28588bc4e3">~Memory</a> ()=default</td></tr>
<tr class="memdesc:a7cb9e2bc14717bc0ffdd0a28588bc4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: default.  <a href="#a7cb9e2bc14717bc0ffdd0a28588bc4e3">More...</a><br/></td></tr>
<tr class="separator:a7cb9e2bc14717bc0ffdd0a28588bc4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6852612dbcd826906a755adfc701c769"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a6852612dbcd826906a755adfc701c769">OwnsHostPtr</a> () const </td></tr>
<tr class="memdesc:a6852612dbcd826906a755adfc701c769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the host pointer is owned. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a>.  <a href="#a6852612dbcd826906a755adfc701c769">More...</a><br/></td></tr>
<tr class="separator:a6852612dbcd826906a755adfc701c769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2278da511a1140be310f4bb4fdfed3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#aef2278da511a1140be310f4bb4fdfed3">SetHostPtrOwner</a> (bool own) const </td></tr>
<tr class="memdesc:aef2278da511a1140be310f4bb4fdfed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/clear the ownership flag for the host pointer. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a>.  <a href="#aef2278da511a1140be310f4bb4fdfed3">More...</a><br/></td></tr>
<tr class="separator:aef2278da511a1140be310f4bb4fdfed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeab99ce34ad4012dee127b7cab4c4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#afdeab99ce34ad4012dee127b7cab4c4b">OwnsDevicePtr</a> () const </td></tr>
<tr class="memdesc:afdeab99ce34ad4012dee127b7cab4c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the device pointer is owned. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a>.  <a href="#afdeab99ce34ad4012dee127b7cab4c4b">More...</a><br/></td></tr>
<tr class="separator:afdeab99ce34ad4012dee127b7cab4c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1202d5f1c3324928aba47ee3d2a1d169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a1202d5f1c3324928aba47ee3d2a1d169">SetDevicePtrOwner</a> (bool own) const </td></tr>
<tr class="memdesc:a1202d5f1c3324928aba47ee3d2a1d169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/clear the ownership flag for the device pointer. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a>.  <a href="#a1202d5f1c3324928aba47ee3d2a1d169">More...</a><br/></td></tr>
<tr class="separator:a1202d5f1c3324928aba47ee3d2a1d169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb4bc8e32f33c9e06780043d4a83c26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#adcb4bc8e32f33c9e06780043d4a83c26">ClearOwnerFlags</a> () const </td></tr>
<tr class="memdesc:adcb4bc8e32f33c9e06780043d4a83c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the ownership flags for the host and device pointers, as well as any internal data allocated by the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object.  <a href="#adcb4bc8e32f33c9e06780043d4a83c26">More...</a><br/></td></tr>
<tr class="separator:adcb4bc8e32f33c9e06780043d4a83c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55b575d126eca2e3229105304751517"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ab55b575d126eca2e3229105304751517">UseDevice</a> () const </td></tr>
<tr class="memdesc:ab55b575d126eca2e3229105304751517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the internal device flag.  <a href="#ab55b575d126eca2e3229105304751517">More...</a><br/></td></tr>
<tr class="separator:ab55b575d126eca2e3229105304751517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e0590d22f41f02d877e5fc50c98bd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a25e0590d22f41f02d877e5fc50c98bd7">UseDevice</a> (bool use_dev) const </td></tr>
<tr class="memdesc:a25e0590d22f41f02d877e5fc50c98bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal device flag.  <a href="#a25e0590d22f41f02d877e5fc50c98bd7">More...</a><br/></td></tr>
<tr class="separator:a25e0590d22f41f02d877e5fc50c98bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ad0de14bbbd20a93e4f1c9215b2179"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ab5ad0de14bbbd20a93e4f1c9215b2179">Capacity</a> () const </td></tr>
<tr class="memdesc:ab5ad0de14bbbd20a93e4f1c9215b2179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the allocated memory.  <a href="#ab5ad0de14bbbd20a93e4f1c9215b2179">More...</a><br/></td></tr>
<tr class="separator:ab5ad0de14bbbd20a93e4f1c9215b2179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cb658936a2f7ef0033e7144b8f2ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ae0cb658936a2f7ef0033e7144b8f2ded">Reset</a> ()</td></tr>
<tr class="memdesc:ae0cb658936a2f7ef0033e7144b8f2ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the memory to be empty, ensuring that <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a> will be a no-op.  <a href="#ae0cb658936a2f7ef0033e7144b8f2ded">More...</a><br/></td></tr>
<tr class="separator:ae0cb658936a2f7ef0033e7144b8f2ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7fedbcdbd7866b6b00ff87b062214e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#afa7fedbcdbd7866b6b00ff87b062214e">Empty</a> () const </td></tr>
<tr class="memdesc:afa7fedbcdbd7866b6b00ff87b062214e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object is empty, see <a class="el" href="classmfem_1_1Memory.html#ae0cb658936a2f7ef0033e7144b8f2ded" title="Reset the memory to be empty, ensuring that Delete() will be a no-op. ">Reset()</a>.  <a href="#afa7fedbcdbd7866b6b00ff87b062214e">More...</a><br/></td></tr>
<tr class="separator:afa7fedbcdbd7866b6b00ff87b062214e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8653bd0ddede4b32b498d56eab7a72f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#af8653bd0ddede4b32b498d56eab7a72f">New</a> (int size)</td></tr>
<tr class="memdesc:af8653bd0ddede4b32b498d56eab7a72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate host memory for <em>size</em> entries with type <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6ab9361011891280a44d85b967739cc6a5" title="Host memory; using new[] and delete[]. ">MemoryType::HOST</a>.  <a href="#af8653bd0ddede4b32b498d56eab7a72f">More...</a><br/></td></tr>
<tr class="separator:af8653bd0ddede4b32b498d56eab7a72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bbd339334b49ff73abee09cf3f60ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a08bbd339334b49ff73abee09cf3f60ec">New</a> (int size, <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> mt)</td></tr>
<tr class="memdesc:a08bbd339334b49ff73abee09cf3f60ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for <em>size</em> entries with the given MemoryType.  <a href="#a08bbd339334b49ff73abee09cf3f60ec">More...</a><br/></td></tr>
<tr class="separator:a08bbd339334b49ff73abee09cf3f60ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33f0d9783e1129d8cf9d792b1aa360f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ae33f0d9783e1129d8cf9d792b1aa360f">Wrap</a> (T *ptr, int size, bool own)</td></tr>
<tr class="memdesc:ae33f0d9783e1129d8cf9d792b1aa360f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an externally allocated host pointer, <em>ptr</em> with type <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6ab9361011891280a44d85b967739cc6a5" title="Host memory; using new[] and delete[]. ">MemoryType::HOST</a>.  <a href="#ae33f0d9783e1129d8cf9d792b1aa360f">More...</a><br/></td></tr>
<tr class="separator:ae33f0d9783e1129d8cf9d792b1aa360f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109d0d1215affe85a413f182f7c1e829"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a109d0d1215affe85a413f182f7c1e829">Wrap</a> (T *ptr, int size, <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> mt, bool own)</td></tr>
<tr class="memdesc:a109d0d1215affe85a413f182f7c1e829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an externally allocated pointer, <em>ptr</em>, of the given MemoryType.  <a href="#a109d0d1215affe85a413f182f7c1e829">More...</a><br/></td></tr>
<tr class="separator:a109d0d1215affe85a413f182f7c1e829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c80c40247a6a501cbc892063c19410"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a54c80c40247a6a501cbc892063c19410">MakeAlias</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;base, int offset, int size)</td></tr>
<tr class="memdesc:a54c80c40247a6a501cbc892063c19410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a memory object that points inside the memory object <em>base</em>.  <a href="#a54c80c40247a6a501cbc892063c19410">More...</a><br/></td></tr>
<tr class="separator:a54c80c40247a6a501cbc892063c19410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae561fa2849413502ad438425d430ab3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e">Delete</a> ()</td></tr>
<tr class="memdesc:ae561fa2849413502ad438425d430ab3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the owned pointers. The <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> is not reset by this method.  <a href="#ae561fa2849413502ad438425d430ab3e">More...</a><br/></td></tr>
<tr class="separator:ae561fa2849413502ad438425d430ab3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe83db8e05919fc63ddba24b823bf7b"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a2fe83db8e05919fc63ddba24b823bf7b">operator[]</a> (int idx)</td></tr>
<tr class="memdesc:a2fe83db8e05919fc63ddba24b823bf7b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmfem_1_1Array.html">Array</a> subscript operator for host memory.  <a href="#a2fe83db8e05919fc63ddba24b823bf7b">More...</a><br/></td></tr>
<tr class="separator:a2fe83db8e05919fc63ddba24b823bf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695c1b5065d59b02bc35bfa2f80a6b68"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a695c1b5065d59b02bc35bfa2f80a6b68">operator[]</a> (int idx) const </td></tr>
<tr class="memdesc:a695c1b5065d59b02bc35bfa2f80a6b68"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmfem_1_1Array.html">Array</a> subscript operator for host memory, const version.  <a href="#a695c1b5065d59b02bc35bfa2f80a6b68">More...</a><br/></td></tr>
<tr class="separator:a695c1b5065d59b02bc35bfa2f80a6b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa10cc1aebba6e2e97dc837beedad38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a5aa10cc1aebba6e2e97dc837beedad38">operator T *</a> ()</td></tr>
<tr class="memdesc:a5aa10cc1aebba6e2e97dc837beedad38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the host memory as T* (implicit conversion).  <a href="#a5aa10cc1aebba6e2e97dc837beedad38">More...</a><br/></td></tr>
<tr class="separator:a5aa10cc1aebba6e2e97dc837beedad38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd070cec041a69f27e6c409ac28c5842"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#acd070cec041a69f27e6c409ac28c5842">operator const T *</a> () const </td></tr>
<tr class="memdesc:acd070cec041a69f27e6c409ac28c5842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the host memory as const T* (implicit conversion).  <a href="#acd070cec041a69f27e6c409ac28c5842">More...</a><br/></td></tr>
<tr class="separator:acd070cec041a69f27e6c409ac28c5842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61fa8b5b24da153045eaf64585e9ba4"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ab61fa8b5b24da153045eaf64585e9ba4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ab61fa8b5b24da153045eaf64585e9ba4">operator U *</a> ()</td></tr>
<tr class="memdesc:ab61fa8b5b24da153045eaf64585e9ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the host memory via explicit typecast.  <a href="#ab61fa8b5b24da153045eaf64585e9ba4">More...</a><br/></td></tr>
<tr class="separator:ab61fa8b5b24da153045eaf64585e9ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3f195b29c6c15daa22c28b6c8a3334"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a9f3f195b29c6c15daa22c28b6c8a3334"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a9f3f195b29c6c15daa22c28b6c8a3334">operator const U *</a> () const </td></tr>
<tr class="memdesc:a9f3f195b29c6c15daa22c28b6c8a3334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the host memory via explicit typecast, const version.  <a href="#a9f3f195b29c6c15daa22c28b6c8a3334">More...</a><br/></td></tr>
<tr class="separator:a9f3f195b29c6c15daa22c28b6c8a3334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c5196970fcdb804fda39b12ce33a89"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a41c5196970fcdb804fda39b12ce33a89">ReadWrite</a> (<a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9ad">MemoryClass</a> mc, int size)</td></tr>
<tr class="memdesc:a41c5196970fcdb804fda39b12ce33a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get read-write access to the memory with the given MemoryClass.  <a href="#a41c5196970fcdb804fda39b12ce33a89">More...</a><br/></td></tr>
<tr class="separator:a41c5196970fcdb804fda39b12ce33a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5c11ddc964f3e9828e9a2049a5210d"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a8a5c11ddc964f3e9828e9a2049a5210d">Read</a> (<a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9ad">MemoryClass</a> mc, int size) const </td></tr>
<tr class="memdesc:a8a5c11ddc964f3e9828e9a2049a5210d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get read-only access to the memory with the given MemoryClass.  <a href="#a8a5c11ddc964f3e9828e9a2049a5210d">More...</a><br/></td></tr>
<tr class="separator:a8a5c11ddc964f3e9828e9a2049a5210d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e426fd5bdf03fced16e7fc748e618b3"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a0e426fd5bdf03fced16e7fc748e618b3">Write</a> (<a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9ad">MemoryClass</a> mc, int size)</td></tr>
<tr class="memdesc:a0e426fd5bdf03fced16e7fc748e618b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get write-only access to the memory with the given MemoryClass.  <a href="#a0e426fd5bdf03fced16e7fc748e618b3">More...</a><br/></td></tr>
<tr class="separator:a0e426fd5bdf03fced16e7fc748e618b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061fbb4a0581e4aee9e0095da57cb725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a061fbb4a0581e4aee9e0095da57cb725">Sync</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;other) const </td></tr>
<tr class="memdesc:a061fbb4a0581e4aee9e0095da57cb725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the host/device pointer validity flags from <em>other</em> to <em>*this</em>.  <a href="#a061fbb4a0581e4aee9e0095da57cb725">More...</a><br/></td></tr>
<tr class="separator:a061fbb4a0581e4aee9e0095da57cb725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27958058c25c6ac94f0094ad884f4a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#af27958058c25c6ac94f0094ad884f4a2">SyncAlias</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;base, int alias_size) const </td></tr>
<tr class="memdesc:af27958058c25c6ac94f0094ad884f4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the alias <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> <em>*this</em> to match the memory location (all valid locations) of its base <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a>, <em>base</em>.  <a href="#af27958058c25c6ac94f0094ad884f4a2">More...</a><br/></td></tr>
<tr class="separator:af27958058c25c6ac94f0094ad884f4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2890e4aeb888a2c48edb4fe720624600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a2890e4aeb888a2c48edb4fe720624600">GetMemoryType</a> () const </td></tr>
<tr class="memdesc:a2890e4aeb888a2c48edb4fe720624600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemoryType that is currently valid. If both the host and the device pointers are currently valid, then the device memory type is returned.  <a href="#a2890e4aeb888a2c48edb4fe720624600">More...</a><br/></td></tr>
<tr class="separator:a2890e4aeb888a2c48edb4fe720624600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35b55cdb9f0501fc80c17a0d771d2c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ad35b55cdb9f0501fc80c17a0d771d2c5">CopyFrom</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;src, int size)</td></tr>
<tr class="memdesc:ad35b55cdb9f0501fc80c17a0d771d2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <em>size</em> entries from <em>src</em> to <em>*this</em>.  <a href="#ad35b55cdb9f0501fc80c17a0d771d2c5">More...</a><br/></td></tr>
<tr class="separator:ad35b55cdb9f0501fc80c17a0d771d2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9cc62d4a62456f698a39ddf9010319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a2f9cc62d4a62456f698a39ddf9010319">CopyFromHost</a> (const T *src, int size)</td></tr>
<tr class="memdesc:a2f9cc62d4a62456f698a39ddf9010319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <em>size</em> entries from the host pointer <em>src</em> to <em>*this</em>.  <a href="#a2f9cc62d4a62456f698a39ddf9010319">More...</a><br/></td></tr>
<tr class="separator:a2f9cc62d4a62456f698a39ddf9010319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacab41762dcd16c08fdf98b9d1b7e28c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#aacab41762dcd16c08fdf98b9d1b7e28c">CopyTo</a> (<a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;dest, int size) const </td></tr>
<tr class="memdesc:aacab41762dcd16c08fdf98b9d1b7e28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <em>size</em> entries from <em>*this</em> to <em>dest</em>.  <a href="#aacab41762dcd16c08fdf98b9d1b7e28c">More...</a><br/></td></tr>
<tr class="separator:aacab41762dcd16c08fdf98b9d1b7e28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfcac3871b72bdc63a4db088e3c6d56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#adbfcac3871b72bdc63a4db088e3c6d56">CopyToHost</a> (T *dest, int size) const </td></tr>
<tr class="memdesc:adbfcac3871b72bdc63a4db088e3c6d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <em>size</em> entries from <em>*this</em> to the host pointer <em>dest</em>.  <a href="#adbfcac3871b72bdc63a4db088e3c6d56">More...</a><br/></td></tr>
<tr class="separator:adbfcac3871b72bdc63a4db088e3c6d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a7a1e08479f01d72273d3acd224acd739"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a7a1e08479f01d72273d3acd224acd739">FlagMask</a> { <br/>
&#160;&#160;<a class="el" href="classmfem_1_1Memory.html#a7a1e08479f01d72273d3acd224acd739a71f2794e3bbd9eaa78d79f8674247d35">REGISTERED</a> = 1, 
<a class="el" href="classmfem_1_1Memory.html#a7a1e08479f01d72273d3acd224acd739a82221cef35fabed8dfcbf4535e32f98e">OWNS_HOST</a> = 2, 
<a class="el" href="classmfem_1_1Memory.html#a7a1e08479f01d72273d3acd224acd739a068c473e63b3975e76bd7ffa97b9b5c3">OWNS_DEVICE</a> = 4, 
<a class="el" href="classmfem_1_1Memory.html#a7a1e08479f01d72273d3acd224acd739a1ba40eda130ac33b05d137ef20a228ce">OWNS_INTERNAL</a> = 8, 
<br/>
&#160;&#160;<a class="el" href="classmfem_1_1Memory.html#a7a1e08479f01d72273d3acd224acd739a5929d77e0509d40bc61e2d8a0e80b435">VALID_HOST</a> = 16, 
<a class="el" href="classmfem_1_1Memory.html#a7a1e08479f01d72273d3acd224acd739a8dc25949c78815465778215543d1bfe9">VALID_DEVICE</a> = 32, 
<a class="el" href="classmfem_1_1Memory.html#a7a1e08479f01d72273d3acd224acd739ada467ac084790b0980b43e91c3af13b7">ALIAS</a> = 64, 
<a class="el" href="classmfem_1_1Memory.html#a7a1e08479f01d72273d3acd224acd739a2e40ee01ee74c826ca6999aef88c179a">USE_DEVICE</a> = 128
<br/>
 }</td></tr>
<tr class="separator:a7a1e08479f01d72273d3acd224acd739"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab74d8712d2e64510cf8bfd256b656c16"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ab74d8712d2e64510cf8bfd256b656c16">h_ptr</a></td></tr>
<tr class="memdesc:ab74d8712d2e64510cf8bfd256b656c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to host memory. Not owned.  <a href="#ab74d8712d2e64510cf8bfd256b656c16">More...</a><br/></td></tr>
<tr class="separator:ab74d8712d2e64510cf8bfd256b656c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d2f083d939a842e7a822882c69615c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#af3d2f083d939a842e7a822882c69615c">capacity</a></td></tr>
<tr class="separator:af3d2f083d939a842e7a822882c69615c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac929fdb65bbfc48a96dc53479c680a6f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ac929fdb65bbfc48a96dc53479c680a6f">flags</a></td></tr>
<tr class="separator:ac929fdb65bbfc48a96dc53479c680a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a714d9445184f29c663c1c02da59e9727"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a714d9445184f29c663c1c02da59e9727">MemoryManager</a></td></tr>
<tr class="separator:a714d9445184f29c663c1c02da59e9727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80ea4d950a39cb98da7a6da3cf862bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#aa80ea4d950a39cb98da7a6da3cf862bc">MemoryPrintFlags</a> (unsigned <a class="el" href="classmfem_1_1Memory.html#ac929fdb65bbfc48a96dc53479c680a6f">flags</a>)</td></tr>
<tr class="memdesc:aa80ea4d950a39cb98da7a6da3cf862bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the state of a <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object based on its internal flags. Useful in a debugger.  <a href="#aa80ea4d950a39cb98da7a6da3cf862bc">More...</a><br/></td></tr>
<tr class="separator:aa80ea4d950a39cb98da7a6da3cf862bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class mfem::Memory&lt; T &gt;</h3>

<p>Class used by MFEM to store pointers to host and/or device memory. </p>
<p>The template class parameter, T, must be a plain-old-data (POD) type.</p>
<p>In many respects this class behaves like a pointer: When destroyed, a <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object does NOT automatically delete any allocated memory. Only the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a> will deallocate a <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object. Other methods that modify the object (e.g. <a class="el" href="classmfem_1_1Memory.html#af8653bd0ddede4b32b498d56eab7a72f" title="Allocate host memory for size entries with type MemoryType::HOST. ">New()</a>, <a class="el" href="classmfem_1_1Memory.html#ae33f0d9783e1129d8cf9d792b1aa360f" title="Wrap an externally allocated host pointer, ptr with type MemoryType::HOST. ">Wrap()</a>, etc) will simply overwrite the old contents. One difference with a pointer is that a const <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object does not allow modification of the content (unlike e.g. a const pointer).</p>
<p>A <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object stores up to two different pointers: one host pointer (with MemoryType from <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6ab9361011891280a44d85b967739cc6a5" title="Host memory; using new[] and delete[]. ">MemoryClass::HOST</a>) and one device pointer (currently one of <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6aa33b7755e5f9b504d2d038eaca4ff28d" title="cudaMalloc, cudaFree ">MemoryType::CUDA</a> or <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6afbd82913f598b9425894b17f2402f3cf" title="cudaMallocManaged, cudaFree (not supported yet) ">MemoryTyep::CUDA_UVM</a>).</p>
<p>A <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object can hold (wrap) an externally allocated pointer with any given MemoryType.</p>
<p>Access to the content of the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object can be requested with any given MemoryClass through the methods <a class="el" href="classmfem_1_1Memory.html#a41c5196970fcdb804fda39b12ce33a89" title="Get read-write access to the memory with the given MemoryClass. ">ReadWrite()</a>, <a class="el" href="classmfem_1_1Memory.html#a8a5c11ddc964f3e9828e9a2049a5210d" title="Get read-only access to the memory with the given MemoryClass. ">Read()</a>, and <a class="el" href="classmfem_1_1Memory.html#a0e426fd5bdf03fced16e7fc748e618b3" title="Get write-only access to the memory with the given MemoryClass. ">Write()</a>. Requesting such access may result in additional (internally handled) memory allocation and/or memory copy. When <a class="el" href="classmfem_1_1Memory.html#a41c5196970fcdb804fda39b12ce33a89" title="Get read-write access to the memory with the given MemoryClass. ">ReadWrite()</a> is called, the returned pointer becomes the only valid pointer. When <a class="el" href="classmfem_1_1Memory.html#a8a5c11ddc964f3e9828e9a2049a5210d" title="Get read-only access to the memory with the given MemoryClass. ">Read()</a> is called, the returned pointer becomes valid, however the other pointer (host or device) may remain valid as well. When <a class="el" href="classmfem_1_1Memory.html#a0e426fd5bdf03fced16e7fc748e618b3" title="Get write-only access to the memory with the given MemoryClass. ">Write()</a> is called, the returned pointer becomes the only valid pointer, however, unlike <a class="el" href="classmfem_1_1Memory.html#a41c5196970fcdb804fda39b12ce33a89" title="Get read-write access to the memory with the given MemoryClass. ">ReadWrite()</a>, no memory copy will be performed.</p>
<p>The host memory (pointer from <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6ab9361011891280a44d85b967739cc6a5" title="Host memory; using new[] and delete[]. ">MemoryClass::HOST</a>) can be accessed through the inline methods: <code><a class="el" href="classmfem_1_1Memory.html#a2fe83db8e05919fc63ddba24b823bf7b" title="Array subscript operator for host memory. ">operator[]()</a></code>, <code><a class="el" href="namespacemfem.html#a1dd8fb57059a48b1904c99f33ed3ad5f" title="Return a suitable MemoryClass from a pair of MemoryClasses. ">operator*()</a></code>, the implicit conversion functions <code>operator T*()</code>, <code>operator const T*()</code>, and the explicit conversion template functions <code>operator U*()</code>, <code>operator const U*()</code> (with any suitable type U). In certain cases, using these methods may have undefined behavior, e.g. if the host pointer is not currently valid. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00102">102</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a7a1e08479f01d72273d3acd224acd739"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmfem_1_1Memory.html#a7a1e08479f01d72273d3acd224acd739">mfem::Memory::FlagMask</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a7a1e08479f01d72273d3acd224acd739a71f2794e3bbd9eaa78d79f8674247d35"></a>REGISTERED</em>&nbsp;</td><td class="fielddoc">
<p><a class="el" href="classmfem_1_1Memory.html#ab74d8712d2e64510cf8bfd256b656c16" title="Pointer to host memory. Not owned. ">h_ptr</a> is registered with the <a class="el" href="classmfem_1_1MemoryManager.html" title="The memory manager class. ">MemoryManager</a> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7a1e08479f01d72273d3acd224acd739a82221cef35fabed8dfcbf4535e32f98e"></a>OWNS_HOST</em>&nbsp;</td><td class="fielddoc">
<p>The host pointer will be deleted by <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7a1e08479f01d72273d3acd224acd739a068c473e63b3975e76bd7ffa97b9b5c3"></a>OWNS_DEVICE</em>&nbsp;</td><td class="fielddoc">
<p>The device pointer will be deleted by <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7a1e08479f01d72273d3acd224acd739a1ba40eda130ac33b05d137ef20a228ce"></a>OWNS_INTERNAL</em>&nbsp;</td><td class="fielddoc">
<p>Ownership flag for internal <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> data. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7a1e08479f01d72273d3acd224acd739a5929d77e0509d40bc61e2d8a0e80b435"></a>VALID_HOST</em>&nbsp;</td><td class="fielddoc">
<p>Host pointer is valid. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7a1e08479f01d72273d3acd224acd739a8dc25949c78815465778215543d1bfe9"></a>VALID_DEVICE</em>&nbsp;</td><td class="fielddoc">
<p><a class="el" href="classmfem_1_1Device.html" title="The MFEM Device class abstracts hardware devices such as GPUs, as well as programming models such as ...">Device</a> pointer is valid. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7a1e08479f01d72273d3acd224acd739ada467ac084790b0980b43e91c3af13b7"></a>ALIAS</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7a1e08479f01d72273d3acd224acd739a2e40ee01ee74c826ca6999aef88c179a"></a>USE_DEVICE</em>&nbsp;</td><td class="fielddoc">
<p>Internal device flag, see e.g. <a class="el" href="classmfem_1_1Vector.html#a7f8f636001c0ca1c488d622d4ea3a2b7" title="Enable execution of Vector operations using the mfem::Device. ">Vector::UseDevice()</a> </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00108">108</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7af6e87336d9ae575d795a92511fd43c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::<a class="el" href="classmfem_1_1Memory.html">Memory</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor: no initialization. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00133">133</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abbee21dd0c326971e91d11fa4245bbf3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::<a class="el" href="classmfem_1_1Memory.html">Memory</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: default. </p>

</div>
</div>
<a class="anchor" id="ab23d9cfade7ef4ab02cba0d57ecf039a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::<a class="el" href="classmfem_1_1Memory.html">Memory</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor: default. </p>

</div>
</div>
<a class="anchor" id="ae1c01fd9d1a0c4ab67a0ca0c98680412"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::<a class="el" href="classmfem_1_1Memory.html">Memory</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate host memory for <em>size</em> entries. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00148">148</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a102f6d8ce2d661f85de4b0f128699515"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::<a class="el" href="classmfem_1_1Memory.html">Memory</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>mt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for <em>size</em> entries with the given MemoryType <em>mt</em>. </p>
<p>The newly allocated memory is not initialized, however the given MemoryType is still set as valid. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00154">154</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="affa79572a7c2f7a6c9fb4aeb84ad4661"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::<a class="el" href="classmfem_1_1Memory.html">Memory</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an externally allocated host pointer, <em>ptr</em> with type <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6ab9361011891280a44d85b967739cc6a5" title="Host memory; using new[] and delete[]. ">MemoryType::HOST</a>. </p>
<p>The parameter <em>own</em> determines whether <em>ptr</em> will be deleted (using operator delete[]) when the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a> is called. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00160">160</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae6b741efdece127b62d558f2d6cda057"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::<a class="el" href="classmfem_1_1Memory.html">Memory</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>mt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an externally allocated pointer, <em>ptr</em>, of the given MemoryType. </p>
<p>The new memory object will have the given MemoryType set as valid.</p>
<p>The given <em>ptr</em> must be allocated appropriately for the given MemoryType.</p>
<p>The parameter <em>own</em> determines whether <em>ptr</em> will be deleted when the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a> is called. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00170">170</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12f74a8f481da9350110e69403339d44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::<a class="el" href="classmfem_1_1Memory.html">Memory</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias constructor. Create a <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object that points inside the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object <em>base</em>. </p>
<p>The new <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object uses the same MemoryType(s) as <em>base</em>. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00176">176</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7cb9e2bc14717bc0ffdd0a28588bc4e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::~<a class="el" href="classmfem_1_1Memory.html">Memory</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor: default. </p>
<dl class="section note"><dt>Note</dt><dd>The destructor will NOT delete the current memory. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab5ad0de14bbbd20a93e4f1c9215b2179"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the allocated memory. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00214">214</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adcb4bc8e32f33c9e06780043d4a83c26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::ClearOwnerFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the ownership flags for the host and device pointers, as well as any internal data allocated by the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00203">203</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad35b55cdb9f0501fc80c17a0d771d2c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::CopyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy <em>size</em> entries from <em>src</em> to <em>*this</em>. </p>
<p>The given <em>size</em> should not exceed the <a class="el" href="classmfem_1_1Memory.html#ab5ad0de14bbbd20a93e4f1c9215b2179" title="Return the size of the allocated memory. ">Capacity()</a> of the source <em>src</em> and the destination, <em>*this</em>. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00673">673</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2f9cc62d4a62456f698a39ddf9010319"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::CopyFromHost </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy <em>size</em> entries from the host pointer <em>src</em> to <em>*this</em>. </p>
<p>The given <em>size</em> should not exceed the <a class="el" href="classmfem_1_1Memory.html#ab5ad0de14bbbd20a93e4f1c9215b2179" title="Return the size of the allocated memory. ">Capacity()</a> of <em>*this</em>. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00692">692</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aacab41762dcd16c08fdf98b9d1b7e28c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::CopyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy <em>size</em> entries from <em>*this</em> to <em>dest</em>. </p>
<p>The given <em>size</em> should not exceed the <a class="el" href="classmfem_1_1Memory.html#ab5ad0de14bbbd20a93e4f1c9215b2179" title="Return the size of the allocated memory. ">Capacity()</a> of <em>*this</em> and the destination, <em>dest</em>. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00374">374</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adbfcac3871b72bdc63a4db088e3c6d56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::CopyToHost </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy <em>size</em> entries from <em>*this</em> to the host pointer <em>dest</em>. </p>
<p>The given <em>size</em> should not exceed the <a class="el" href="classmfem_1_1Memory.html#ab5ad0de14bbbd20a93e4f1c9215b2179" title="Return the size of the allocated memory. ">Capacity()</a> of <em>*this</em>. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00711">711</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae561fa2849413502ad438425d430ab3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Delete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the owned pointers. The <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> is not reset by this method. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00542">542</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa7fedbcdbd7866b6b00ff87b062214e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object is empty, see <a class="el" href="classmfem_1_1Memory.html#ae0cb658936a2f7ef0033e7144b8f2ded" title="Reset the memory to be empty, ensuring that Delete() will be a no-op. ">Reset()</a>. </p>
<p>Default-constructed objects are uninitialized, so they are not guaranteed to be empty. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00226">226</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2890e4aeb888a2c48edb4fe720624600"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::GetMemoryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a MemoryType that is currently valid. If both the host and the device pointers are currently valid, then the device memory type is returned. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00666">666</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54c80c40247a6a501cbc892063c19410"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::MakeAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a memory object that points inside the memory object <em>base</em>. </p>
<p>The new <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object uses the same MemoryType(s) as <em>base</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The current memory is NOT deleted by this method. </dd></dl>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00526">526</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8653bd0ddede4b32b498d56eab7a72f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::New </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate host memory for <em>size</em> entries with type <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6ab9361011891280a44d85b967739cc6a5" title="Host memory; using new[] and delete[]. ">MemoryType::HOST</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The current memory is NOT deleted by this method. </dd></dl>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00230">230</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08bbd339334b49ff73abee09cf3f60ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::New </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>mt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for <em>size</em> entries with the given MemoryType. </p>
<p>The newly allocated memory is not initialized, however the given MemoryType is still set as valid.</p>
<dl class="section note"><dt>Note</dt><dd>The current memory is NOT deleted by this method. </dd></dl>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00491">491</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd070cec041a69f27e6c409ac28c5842"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator const T * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the host memory as const T* (implicit conversion). </p>
<p>This method can be used only if the host pointer is currently valid (the device pointer may be valid or invalid).</p>
<p>When the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> is empty, this method can be used and it returns NULL. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00577">577</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f3f195b29c6c15daa22c28b6c8a3334"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator const U * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the host memory via explicit typecast, const version. </p>
<p>A pointer to type T must be reinterpret_cast-able to a pointer to type const U.</p>
<p>This method can be used only if the host pointer is currently valid (the device pointer may be valid or invalid).</p>
<p>When the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> is empty, this method can be used and it returns NULL. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00594">594</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5aa10cc1aebba6e2e97dc837beedad38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator T * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the host memory as T* (implicit conversion). </p>
<p>When the type T is const-qualified, this method can be used only if the host pointer is currently valid (the device pointer may be valid or invalid).</p>
<p>When the type T is not const-qualified, this method can be used only if the host pointer is the only valid pointer.</p>
<p>When the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> is empty, this method can be used and it returns NULL. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00567">567</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab61fa8b5b24da153045eaf64585e9ba4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator U * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the host memory via explicit typecast. </p>
<p>A pointer to type T must be reinterpret_cast-able to a pointer to type U. In particular, this method cannot be used to cast away const-ness from the base type T.</p>
<p>When the type U is const-qualified, this method can be used only if the host pointer is currently valid (the device pointer may be valid or invalid).</p>
<p>When the type U is not const-qualified, this method can be used only if the host pointer is the only valid pointer.</p>
<p>When the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> is empty, this method can be used and it returns NULL. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00584">584</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a147b6128bf463085665af1f6ea56eaff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">Memory</a>&amp; <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assignment operator: default. </p>

</div>
</div>
<a class="anchor" id="aaa2aeb6c8b77fd55a796a7398ccb1ba2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">Memory</a>&amp; <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assignment operator: default. </p>

</div>
</div>
<a class="anchor" id="a2fe83db8e05919fc63ddba24b823bf7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmfem_1_1Array.html">Array</a> subscript operator for host memory. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00552">552</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a695c1b5065d59b02bc35bfa2f80a6b68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmfem_1_1Array.html">Array</a> subscript operator for host memory, const version. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00560">560</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afdeab99ce34ad4012dee127b7cab4c4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::OwnsDevicePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the device pointer is owned. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a>. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00194">194</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6852612dbcd826906a755adfc701c769"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::OwnsHostPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the host pointer is owned. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a>. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00185">185</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a5c11ddc964f3e9828e9a2049a5210d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9ad">MemoryClass</a>&#160;</td>
          <td class="paramname"><em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get read-only access to the memory with the given MemoryClass. </p>
<p>The parameter <em>size</em> must not exceed the <a class="el" href="classmfem_1_1Memory.html#ab5ad0de14bbbd20a93e4f1c9215b2179" title="Return the size of the allocated memory. ">Capacity()</a>. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00614">614</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41c5196970fcdb804fda39b12ce33a89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::ReadWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9ad">MemoryClass</a>&#160;</td>
          <td class="paramname"><em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get read-write access to the memory with the given MemoryClass. </p>
<p>If only read or only write access is needed, then the methods <a class="el" href="classmfem_1_1Memory.html#a8a5c11ddc964f3e9828e9a2049a5210d" title="Get read-only access to the memory with the given MemoryClass. ">Read()</a> or <a class="el" href="classmfem_1_1Memory.html#a0e426fd5bdf03fced16e7fc748e618b3" title="Get write-only access to the memory with the given MemoryClass. ">Write()</a> should be used instead of this method.</p>
<p>The parameter <em>size</em> must not exceed the <a class="el" href="classmfem_1_1Memory.html#ab5ad0de14bbbd20a93e4f1c9215b2179" title="Return the size of the allocated memory. ">Capacity()</a>. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00601">601</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0cb658936a2f7ef0033e7144b8f2ded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the memory to be empty, ensuring that <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a> will be a no-op. </p>
<p>This is the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> class equivalent to setting a pointer to NULL, see <a class="el" href="classmfem_1_1Memory.html#afa7fedbcdbd7866b6b00ff87b062214e" title="Return true if the Memory object is empty, see Reset(). ">Empty()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The current memory is NOT deleted by this method. </dd></dl>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00221">221</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1202d5f1c3324928aba47ee3d2a1d169"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::SetDevicePtrOwner </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set/clear the ownership flag for the device pointer. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a>. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00198">198</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef2278da511a1140be310f4bb4fdfed3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::SetHostPtrOwner </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set/clear the ownership flag for the host pointer. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a>. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00189">189</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a061fbb4a0581e4aee9e0095da57cb725"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Sync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the host/device pointer validity flags from <em>other</em> to <em>*this</em>. </p>
<p>This method synchronizes the pointer validity flags of two <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> objects that use the same host/device pointers, or when <em>*this</em> is an alias (sub-Memory) of <em>other</em>. Typically, this method should be called after <em>other</em> is manipulated in a way that changes its pointer validity flags (e.g. it was moved from device to host memory). </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00641">641</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af27958058c25c6ac94f0094ad884f4a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::SyncAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alias_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the alias <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> <em>*this</em> to match the memory location (all valid locations) of its base <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a>, <em>base</em>. </p>
<p>This method is useful when alias <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> is moved and manipulated in a different memory space. Such operations render the pointer validity flags of the base incorrect. Calling this method will ensure that <em>base</em> is up-to-date. Note that this is achieved by moving/copying <em>*this</em> (if necessary), and not <em>base</em>. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00655">655</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab55b575d126eca2e3229105304751517"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::UseDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the internal device flag. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00207">207</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25e0590d22f41f02d877e5fc50c98bd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::UseDevice </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_dev</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the internal device flag. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00210">210</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae33f0d9783e1129d8cf9d792b1aa360f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Wrap </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an externally allocated host pointer, <em>ptr</em> with type <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6ab9361011891280a44d85b967739cc6a5" title="Host memory; using new[] and delete[]. ">MemoryType::HOST</a>. </p>
<p>The parameter <em>own</em> determines whether <em>ptr</em> will be deleted (using operator delete[]) when the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a> is called.</p>
<dl class="section note"><dt>Note</dt><dd>The current memory is NOT deleted by this method. </dd></dl>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00246">246</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a109d0d1215affe85a413f182f7c1e829"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Wrap </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>mt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an externally allocated pointer, <em>ptr</em>, of the given MemoryType. </p>
<p>The new memory object will have the given MemoryType set as valid.</p>
<p>The given <em>ptr</em> must be allocated appropriately for the given MemoryType.</p>
<p>The parameter <em>own</em> determines whether <em>ptr</em> will be deleted when the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers. The Memory is not reset by this method. ">Delete()</a> is called.</p>
<dl class="section note"><dt>Note</dt><dd>The current memory is NOT deleted by this method. </dd></dl>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00508">508</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e426fd5bdf03fced16e7fc748e618b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9ad">MemoryClass</a>&#160;</td>
          <td class="paramname"><em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get write-only access to the memory with the given MemoryClass. </p>
<p>The parameter <em>size</em> must not exceed the <a class="el" href="classmfem_1_1Memory.html#ab5ad0de14bbbd20a93e4f1c9215b2179" title="Return the size of the allocated memory. ">Capacity()</a>.</p>
<p>The contents of the returned pointer is undefined, unless it was validated by a previous call to <a class="el" href="classmfem_1_1Memory.html#a8a5c11ddc964f3e9828e9a2049a5210d" title="Get read-only access to the memory with the given MemoryClass. ">Read()</a> or <a class="el" href="classmfem_1_1Memory.html#a41c5196970fcdb804fda39b12ce33a89" title="Get read-write access to the memory with the given MemoryClass. ">ReadWrite()</a> with the same MemoryClass. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00628">628</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a714d9445184f29c663c1c02da59e9727"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classmfem_1_1MemoryManager.html">MemoryManager</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00105">105</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa80ea4d950a39cb98da7a6da3cf862bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryPrintFlags </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the state of a <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory. ">Memory</a> object based on its internal flags. Useful in a debugger. </p>

<p>Definition at line <a class="el" href="mem__manager_8cpp_source.html#l00693">693</a> of file <a class="el" href="mem__manager_8cpp_source.html">mem_manager.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="af3d2f083d939a842e7a822882c69615c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00126">126</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac929fdb65bbfc48a96dc53479c680a6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00127">127</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab74d8712d2e64510cf8bfd256b656c16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::h_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to host memory. Not owned. </p>
<p>When the pointer is not registered with the <a class="el" href="classmfem_1_1MemoryManager.html" title="The memory manager class. ">MemoryManager</a>, this pointer has type <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6ab9361011891280a44d85b967739cc6a5" title="Host memory; using new[] and delete[]. ">MemoryType::HOST</a>. When the pointer is registered, it can be any type from <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6ab9361011891280a44d85b967739cc6a5" title="Host memory; using new[] and delete[]. ">MemoryClass::HOST</a>. </p>

<p>Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00125">125</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>general/<a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 18 2022 18:43:48 for MFEM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
